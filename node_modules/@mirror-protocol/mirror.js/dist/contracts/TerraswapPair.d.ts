import { AccAddress, MsgExecuteContract, Coins, MsgInstantiateContract, Numeric } from '@terra-money/terra.js';
import { EmptyObject } from '../utils/EmptyObject';
import { AssetInfo, Asset } from '../utils/Asset';
import { ContractClient } from './ContractClient';
import { TerraswapToken } from './TerraswapToken';
export declare namespace TerraswapPair {
    interface InitHook {
        msg: string;
        contract_addr: AccAddress;
    }
    interface InitMsg {
        asset_infos: [AssetInfo, AssetInfo];
        token_code_id: number;
        init_hook?: InitHook;
    }
    interface HandleProvideLiquidity {
        provide_liquidity: {
            assets: [Asset<AssetInfo>, Asset<AssetInfo>];
            slippage_tolerance?: string;
        };
    }
    interface HandleSwap {
        swap: {
            offer_asset: Asset<AssetInfo>;
            belief_price?: string;
            max_spread?: string;
            to?: AccAddress;
        };
    }
    interface HookSwap {
        swap: {
            belief_price?: string;
            max_spread?: string;
            to?: AccAddress;
        };
    }
    interface HookWithdrawLiquidity {
        withdraw_liquidity: EmptyObject;
    }
    interface QueryPair {
        pair: EmptyObject;
    }
    interface QueryPool {
        pool: EmptyObject;
    }
    interface QuerySimulation {
        simulation: {
            offer_asset: Asset<AssetInfo>;
        };
    }
    interface QueryReverseSimulation {
        reverse_simulation: {
            ask_asset: Asset<AssetInfo>;
        };
    }
    interface PairResponse {
        asset_infos: [AssetInfo, AssetInfo];
        contract_addr: AccAddress;
        liquidity_token: AccAddress;
    }
    interface PoolResponse {
        assets: [Asset<AssetInfo>, Asset<AssetInfo>];
        total_share: string;
    }
    interface SimulationResponse {
        return_amount: string;
        spread_amount: string;
        commission_amount: string;
    }
    interface ReverseSimulationResponse {
        offer_amount: string;
        spread_amount: string;
        commission_amount: string;
    }
    type HandleMsg = HandleProvideLiquidity | HandleSwap;
    type HookMsg = HookSwap | HookWithdrawLiquidity;
    type QueryMsg = QueryPair | QueryPool | QuerySimulation | QueryReverseSimulation;
}
export declare class TerraswapPair extends ContractClient {
    protected getTerraswapToken(contractAddress: AccAddress): TerraswapToken;
    init(init_msg: TerraswapPair.InitMsg, migratable: boolean): MsgInstantiateContract;
    provideLiquidity(assets: [Asset<AssetInfo>, Asset<AssetInfo>]): MsgExecuteContract;
    swap(offer_asset: Asset<AssetInfo>, params: {
        belief_price?: Numeric.Input;
        max_spread?: Numeric.Input;
        to?: AccAddress;
    }): MsgExecuteContract;
    withdrawLiquidity(amount: Numeric.Input, lp_token: TerraswapToken): MsgExecuteContract;
    getPair(): Promise<TerraswapPair.PairResponse>;
    getPool(): Promise<TerraswapPair.PoolResponse>;
    getSimulation(offer_asset: Asset<AssetInfo>): Promise<TerraswapPair.SimulationResponse>;
    getReverseSimulation(ask_asset: Asset<AssetInfo>): Promise<TerraswapPair.ReverseSimulationResponse>;
    protected query<T>(query_msg: TerraswapPair.QueryMsg): Promise<T>;
    protected createExecuteMsg(execute_msg: TerraswapPair.HandleMsg, coins?: Coins.Input): MsgExecuteContract;
}
